#pragma config(Sensor, port3,  TouchSensor,    sensorVexIQ_LED)
#pragma config(Sensor, port4,  Gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port5,  RFLs,           sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port6,  MLs,            sensorVexIQ_ColorGrayscale)
#pragma config(Motor,  motor7,          RHerder,       tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor8,          RMotor,        tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor9,          LHerder,       tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor10,         LArm,          tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor11,         RArm,          tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor12,         LMotor,        tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//variables
int calcThresh(tSensors sensor)
{
	int black = 1000;
	int white = -666;

	//StartTime is equal to nPGMtime
	//nPGMtime is now 2001
	//nPgmTime subtracted by startTime is 1 which is less than 5000
	//This while loop runs for 5 secs

	int startTime = nPgmTime;
	while(nPgmTime-startTime < 5000)
	{
		sleep(50);
		//Detects the brightes white
		if(getColorGrayscale(sensor) > white)
		{
			white = getColorGrayscale(sensor);
		}
		//Detects the darkest black
		if(getColorGrayscale(sensor) < black)
		{
			black = getColorGrayscale(sensor);
		}
	}
	//Calculates Threshold
	int Threshold = (white + black) /2;
	//Displays the treshold, white, and black
	displayVariableValues(line3,Threshold);
	displayVariableValues(line4,white);
	displayVariableValues(line5,black);
	//Wait 3 secs
	sleep(3000);
	//returns threshold
	return Threshold;
}

//function to stop at black line
void waitForBlack(tSensors sensor,int threshold)
{
	repeatUntil(getColorGrayscale(sensor) <=  threshold)
	{
		sleep(10);
	}
}

//function to stop at white line
void waitForWhite(tSensors sensor,int threshold)
{
	repeatUntil(getColorGrayscale(sensor) >=  threshold)
	{
		sleep(10);
	}
}

//function to stop after a few lines
void wait4lines(tSensors sens,int threshold ,int numLines){

	repeat(numLines)
	{
		waitForBlack(sens,threshold);
		waitForWhite(sens,threshold);
	}
}

//LMotorS > RMotorS track left
void lineFollow(tSensors sensor, int LSpeed, int RSpeed, int Thresh)
{
	if(getColorGrayscale(sensor) > Thresh)
	{
		setMotor(LMotor, LSpeed);
		setMotor(RMotor, RSpeed);
		}else{
		setMotor(LMotor, RSpeed);
		setMotor(RMotor, LSpeed);
	}
}

//1. get the lightsensor value
//2. check if that is whiter then our whitest white
//3. check if that is blacker than our blackest black
//Calcuate threshhold

//main task
task main()
{


	MLsThresh = 80;
	RFLsThresh = 80;

	displayTextLine(line1, "RFLs = %d", RFLsThresh);
	displayTextLine(line2, "MLs = %d", MLsThresh);


	resetGyro(Gyro);

	resetMotorEncoder(LMotor);
	resetMotorEncoder(RMotor);

	resetMotorEncoder(LArm);
	resetMotorEncoder(RArm);

	resetMotorEncoder(LHerder);
	resetMotorEncoder(RHerder);

	//MAIN PROGRAM

	//Herders up
	setMotorTarget(LHerder, 70, 20);
	setMotorTarget(RHerder, 70, 20);

	//Turn 90 degrees
	setMotor(LMotor, 80);
	setMotor(RMotor, -15);
	waitForBlack(RFLs, RFLsThresh);{
	waitUntil(getGyroDegrees(Gyro) < -45);


}

	while(getColorGrayscale(MLs) < MLsThresh){
			lineFollow(RFLs, 50, 30, RFLsThresh);
	}
	sleep(750);
	while(getColorGrayscale(MLs) > MLsThresh){
			lineFollow(RFLs, 30, 50, RFLsThresh);
	}
	sleep(750);
	while(getColorGrayscale(MLs) < MLsThresh){
			lineFollow(RFLs, 50, 30, RFLsThresh);
	}
	sleep(750);
	while(getColorGrayscale(MLs) > MLsThresh){
			lineFollow(RFLs, 30, 50, RFLsThresh);
	}
	sleep(750);



}



	/**/

	//Turn 45 degrees then start waiting on the lightSensor
	//Agressive line follow

	//run threshold calculationcolorRedViolet

	//Wait for tap sensor
	//Start main program
	//variable
