#pragma config(Sensor, port7,  TouchSensor,    sensorVexIQ_LED)
#pragma config(Sensor, port8,  LFLs,           sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port9,  Gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port11, MLs,            sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port12, RFLs,           sensorVexIQ_ColorGrayscale)
#pragma config(Motor,  motor1,          LHerder,       tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor2,          LArm,          tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor3,          RArm,          tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor4,          RMotor,        tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor5,          RHerder,       tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          LMotor,        tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//variable

int calcThresh(tSensors sensor)
{
	int black = 1000;
	int white = -666;

	//StartTime is equal to nPGMtime
	//nPGMtime is now 2001
	//nPgmTime subtracted by startTime is 1 which is less than 5000
	//This while loop runs for 5 secs

	int startTime = nPgmTime;
	while(nPgmTime-startTime < 5000)
	{
		sleep(50);
		//Detects the brightes white
		if(getColorGrayscale(sensor) > white)
		{
			white = getColorGrayscale(sensor);
		}
		//Detects the darkest black
		if(getColorGrayscale(sensor) < black)
		{
			black = getColorGrayscale(sensor);

		}
	}
	//Calculates Threshold
	int Threshold = (white + black) /2;
	//Displays the treshold, white, and black
	displayVariableValues(line3,Threshold);
	displayVariableValues(line4,white);
	displayVariableValues(line5,black);
	//Wait 3 secs
	sleep(3000);
	//returns threshold
	return Threshold;
}
//function to stop at black line
void waitForBlack(tSensors sensor,int threshold)
{
	repeatUntil(getColorGrayscale(sensor) <=  threshold)
	{
		sleep(10);
	}
}
///function to stop at white line
void waitForWhite(tSensors sensor,int threshold)
{
	repeatUntil(getColorGrayscale(sensor) >=  threshold)
	{
		sleep(10);
	}
}
//function to stop after a few lines
void wait4lines(tSensors sens,int threshold ,int numLines)
{
	repeat(numLines)
	{
		waitForBlack(sens,threshold);
		waitForWhite(sens,threshold);
	}
}

void lineFollow(tSensors sensor, int LSpeed, int RSpeed, int Thresh){
	if(getColorGrayscale(sensor) > Thresh){
		setMotor(LMotor, LSpeed);
		setMotor(RMotor, RSpeed);
		}else{
		setMotor(LMotor, RSpeed);
		setMotor(RMotor, LSpeed);
	}
}
//1. get the lightsensor value
//2. check if that is whiter then our whitest white
//3. check if that is blacker than our blackest black
//Calcuate threshhold

task auto()
{

	int RFLsThresh, MLsThresh, LFLsThresh;

	//INIT
	//Wait for sensors to start up
	writeDebugStreamLine("%d", getColorGrayscale(RFLs));
	writeDebugStreamLine("%d", getColorGrayscale(MLs));
	sleep(1000);

	setTouchLEDColor(TouchSensor, colorBlue);
	waitUntil(getTouchLEDValue(TouchSensor));
	setTouchLEDColor(TouchSensor,colorYellow);

	//MLsThresh = calcThresh(MLs);
	//RFLsThresh = calcThresh(RFLs);

	MLsThresh = 90;
	RFLsThresh = 80;
	LFLsThresh = 90;


	displayTextLine(line1, "RFLs = %d", RFLsThresh);
	displayTextLine(line1, "MLs = %d", MLsThresh);

	setTouchLEDColor(TouchSensor, colorRed);

	waitUntil(getTouchLEDValue(TouchSensor));

	/**/


	//Start Main Program
	resetGyro(Gyro);
	resetMotorEncoder(LMotor);
	resetMotorEncoder(RMotor);
	resetMotorEncoder(LArm);
	resetMotorEncoder(RArm);
	resetMotorEncoder(LHerder);
	resetMotorEncoder(RHerder);


	//Herders up
	setMotorTarget(LHerder, 57, 20);
	setMotorTarget(RHerder, 57, 20);

	//Turn 45 degrees
	setMotor(LMotor, 60);
	setMotor(RMotor, -20);
	waitUntil(getGyroDegrees(Gyro) < -60);

	setMotor(LMotor, 45);
	setMotor(RMotor, 15);

	waitForBlack(RFLs, RFLsThresh);
	setMotor(LMotor, 30);
	setMotor(RMotor, 20);
	sleep(1000);

/*
	while(getColorGrayscale(MLs) < MLsThresh){
		lineFollow(RFLs, 50, 20, RFLsThresh);
	}
	sleep(500);
	while(getColorGrayscale(MLs) > MLsThresh){
		lineFollow(RFLs, 50, 20, RFLsThresh);
	}*/
sleep(500);
	while(getColorGrayscale(MLs) < MLsThresh){
		lineFollow(RFLs, 50, 30, RFLsThresh);
	}
	sleep(500);
	while(getColorGrayscale(MLs) > MLsThresh){
		lineFollow(RFLs, 50, 32, RFLsThresh);
	}

	resetGyro(Gyro);
	resetMotorEncoder(RHerder);
	resetMotorEncoder(LHerder);

	setMotor(LMotor, -35);
	setMotor(RMotor, 35);
	waitUntil(getGyroDegrees(Gyro) > 10);

	setMotor(RHerder, -50);
	sleep(750);
	setMotor(RHerder, 0);

	resetGyro(Gyro);

	setMotor(LMotor, 35);
	setMotor(RMotor, -35);
	waitUntil(getGyroDegrees(Gyro) < -10);

	repeat(forever){

	if(getColorValue(RFLs) < RFLsThresh && getColorValue(LFLs) < LFLsThresh){
		setMotor(LMotor, -30);
		setMotor(RMotor, -70);
	}

	if(getColorValue(RFLs) > RFLsThresh && getColorValue(LFLs) < LFLsThresh){
		setMotor(LMotor, 0);
		setMotor(RMotor, -70);

	}
	if(getColorValue(RFLs) < RFLsThresh && getColorValue(LFLs) > LFLsThresh){
		setMotor(LMotor, -50);
		setMotor(RMotor, 0);
}
}



	/*

		while(getColorGrayscale(MLs) < MLsThresh){
		lineFollow(RBLs, -50, -20,RBLsThresh );
	}
	sleep(500);
	while(getColorGrayscale(MLs) > MLsThresh){
		lineFollow(RBLs, -50, -20,RBLsThresh );
	}
	sleep(500);
	while(getColorGrayscale(MLs) < MLsThresh){
		lineFollow(RBLs, -50, -30,RBLsThresh );
	}
	sleep(500);
	while(getColorGrayscale(MLs) > MLsThresh){
		lineFollow(RBLs, - 50, -32,RBLsThresh );
}

	resetGyro(Gyro);

	setMotor(LMotor, -35);
	setMotor(RMotor, 35);
	waitUntil(getGyroDegrees(Gyro) > 7);



	//Turn 45 degrees then start waiting on the lint Sensor
	//Agressive line follow

	/**/



	//Tap touch sensor to start threshold calculation
	//run threshold calculation
	//print thresholds on the screen

	//Wait for tap sensor
	//Start main program
	//variable

}

//main task
task main()
{
	startTask(auto);
	while(getJoystickValue(BtnEUp) == false){ sleep(10); }
	stopTask(auto);

	//CHA Vertical Travel
	//CHB Yaw
	//CHC Horizontal Travel
	//CHD Heyo Hoeyo
	int Lherding1, Lherding2, Rherding1, Rherding2, ReadyGrab, Grab;
	//CHD Arm
	unsigned long LHerderTime, RHerderTime;

	bool LisUp, RisUp, LOverride, ROverride, LisMid, RisMid;

	setMotorBrakeMode(LHerder, motorBrake);
	setMotorBrakeMode(RHerder, motorBrake);

	while(true){
		//Grab the joystick values and save them into variables
		//The float type means floating point or decimal
		float speedInput = getJoystickValue(ChA);
		float turnInput = getJoystickValue(ChC);
		float armInput = getJoystickValue(ChD);


		if(getJoystickValue(BtnEUp) == true && LHerderTime < nPgmTime) {
			LOverride = false;
			if(LisUp){
				setMotorBrakeMode(LHerder, motorBrake);
				LHerderTime = nPgmTime + 1000;
				LisUp = false;
				LisMid = false;
			}else{
				setMotorBrakeMode(LHerder, motorHold);
				LHerderTime = nPgmTime + 1000;
				LisUp = true;
				LisMid = false;
			}
		}

		if(Lherding2 == false && getJoystickValue(BtnEDown) == true) {
			if(LisMid){
				setMotorBrakeMode(LHerder, motorBrake);
				LHerderTime = nPgmTime + 1000;
				LisUp = false;
				LisMid = false;
			}
			else{
				setMotorTarget(LHerder, 60, 25);
				LHerderTime = nPgmTime;
				LOverride = true;
				LisMid = true;
			}
		}

		if(LHerderTime > nPgmTime) {
			if(LisUp) setMotor(LHerder, 25);
			else setMotor(LHerder, -25);
		}
		else if(!LOverride) setMotor(LHerder, 0);

		//RIGHT HERDER
		//Handle toggle btn
		if(getJoystickValue(BtnFUp) == true && RHerderTime < nPgmTime) {
			ROverride = false;
			if(RisUp){
				setMotorBrakeMode(RHerder, motorBrake);
				RHerderTime = nPgmTime + 1000;
				RisUp = false;
				RisMid = false;
			}else{
				setMotorBrakeMode(RHerder, motorHold);
				RHerderTime = nPgmTime + 1000;
				RisUp = true;
				RisMid = false;
			}
		}

		//Handle mid pos btn
		if(Rherding2 == false && getJoystickValue(BtnFDown) == true) {
			if(RisMid){
				setMotorBrakeMode(RHerder, motorBrake);
				RHerderTime = nPgmTime + 1000;
				RisUp = false;
				RisMid = false;
			}
			else{
				setMotorTarget(RHerder, 60, 25);
				LHerderTime = nPgmTime;
				ROverride = true;
				RisMid = true;
			}
		}

		//Handle movement
		if(RHerderTime > nPgmTime) {
			if(RisUp) setMotor(RHerder, 25);
			else setMotor(RHerder, -25);
		}
		else if(!ROverride) setMotor(RHerder, 0);


		if(ReadyGrab == false && getJoystickValue(BtnLUp) == true) {setMotorTarget(LArm, 310, 100); sleep(1250); setMotorTarget(RArm, 310, 100);}
		if(Grab == false && getJoystickValue(BtnRUp) == true){
			setMotorTarget(LArm, 275, 100);
			setMotorTarget(RArm, 275, 100);
			setMotor(LMotor, -50);
			setMotor(RMotor, -50);
			sleep(1000);
			setMotorTarget(LArm, 320, 100);
			setMotorTarget(RArm, 320, 100);
			setMotor(LMotor, 0);
			setMotor(RMotor, 0);
			sleep(750);
		}

		Lherding1 = getJoystickValue(BtnEUp);
		Lherding2 = getJoystickValue(BtnEDown);
		Rherding1 = getJoystickValue(BtnFUp);
		Rherding2 = getJoystickValue(BtnFDown);

		ReadyGrab = getJoystickValue(BtnLUp);
		Grab = getJoystickValue(BtnRUp);

		//check if controller value is small enough
		//if it is make it zero
		//this accounts for the poor build of certain controllers minimizing drift
		//abs will remove the negative sign from a number
		if(abs(speedInput) < 0.3) speedInput = 0;
		if(abs(turnInput) < 0.2) turnInput = 0;
		if(abs(armInput) < 0.7) armInput = 0;

		//Set the drive motors
		//this is an arcade format
		setMotor(LMotor, speedInput-turnInput);
		setMotor(RMotor, speedInput+turnInput);

		//Set the arm and strafe motors



		//TODO: add safety

		if(getMotorEncoder(LArm) <= 0 && armInput < 0){
			setMotor(LArm,0);
			setMotor(RArm, 0);
		}
		if(getMotorEncoder(LArm) >= 2100 && armInput > 0){
			setMotor(LArm,0);
			setMotor(RArm, 0);
		}
		else{
			setMotor(LArm, armInput);
			setMotor(RArm, armInput);
		}
	}
}
